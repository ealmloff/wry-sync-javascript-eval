class JSHeap{slots;freeIds;maxId;borrowStackPointer;borrowFrameStack;constructor(){this.slots=[],this.slots[129]=null,this.slots[130]=!0,this.slots[131]=!1,this.slots[128]=void 0,this.freeIds=[],this.maxId=132,this.borrowStackPointer=128,this.borrowFrameStack=[]}insert(value){let id=this.maxId;return this.maxId++,this.slots[id]=value,id}get(id){return this.slots[id]}remove(id){if(id<132)return this.slots[id];let value=this.slots[id];return delete this.slots[id],this.freeIds.push(id),value}has(id){return this.freeIds.indexOf(id)===-1&&id<this.slots.length}heapObjectsAlive(){return this.slots.length-this.freeIds.length-132}addBorrowedRef(obj){if(this.borrowStackPointer<=1)throw new Error("Borrow stack overflow: too many borrowed references in a single operation");return this.borrowStackPointer--,this.slots[this.borrowStackPointer]=obj,this.borrowStackPointer}pushBorrowFrame(){this.borrowFrameStack.push(this.borrowStackPointer)}popBorrowFrame(){let savedPointer=this.borrowFrameStack.pop();if(savedPointer!==void 0){for(let i=this.borrowStackPointer;i<savedPointer;i++)delete this.slots[i];this.borrowStackPointer=savedPointer}}getBorrowStackPointer(){return this.borrowStackPointer}}class DataEncoder{u8Buf;u16Buf;u32Buf;strBuf;constructor(){this.u8Buf=[],this.u16Buf=[],this.u32Buf=[],this.strBuf=[]}pushU8(value){this.u8Buf.push(value&255)}pushU16(value){this.u16Buf.push(value&65535)}pushU32(value){this.u32Buf.push(value>>>0)}pushU64(value){let low=value>>>0,high=Math.floor(value/4294967296)>>>0;this.pushU32(low),this.pushU32(high)}pushU128(value){let low=value>>>0,high=Math.floor(value/18446744073709552000)>>>0;this.pushU64(low),this.pushU64(high)}pushF32(value){let floatBuf=new Float32Array(1);floatBuf[0]=value;let intBuf=new Uint32Array(floatBuf.buffer);this.pushU32(intBuf[0])}pushF64(value){let floatBuf=new Float64Array(1);floatBuf[0]=value;let intBuf=new Uint32Array(floatBuf.buffer);this.pushU32(intBuf[0]),this.pushU32(intBuf[1])}pushStr(value){let encoded=new TextEncoder().encode(value);this.pushU32(encoded.length);for(let i=0;i<encoded.length;i++)this.strBuf.push(encoded[i])}finalize(){let u16Offset=12+this.u32Buf.length*4,u8Offset=u16Offset+this.u16Buf.length*2,strOffset=u8Offset+this.u8Buf.length,totalSize=strOffset+this.strBuf.length,buffer=new ArrayBuffer(totalSize),dataView=new DataView(buffer);dataView.setUint32(0,u16Offset,!0),dataView.setUint32(4,u8Offset,!0),dataView.setUint32(8,strOffset,!0);let offset=12;for(let val of this.u32Buf)dataView.setUint32(offset,val,!0),offset+=4;for(let val of this.u16Buf)dataView.setUint16(offset,val,!0),offset+=2;return new Uint8Array(buffer,u8Offset,this.u8Buf.length).set(this.u8Buf),new Uint8Array(buffer,strOffset,this.strBuf.length).set(this.strBuf),buffer}}class DataDecoder{u8Buf;u8Offset;u16Buf;u16Offset;u32Buf;u32Offset;strBuf;strOffset;constructor(data){let headerView=new DataView(data,0,12),u16ByteOffset=headerView.getUint32(0,!0),u8ByteOffset=headerView.getUint32(4,!0),strByteOffset=headerView.getUint32(8,!0),u32ByteLength=u16ByteOffset-12;this.u32Buf=new Uint32Array(data,12,u32ByteLength/4),this.u32Offset=0;let u16ByteLength=u8ByteOffset-u16ByteOffset;this.u16Buf=new Uint16Array(data,u16ByteOffset,u16ByteLength/2),this.u16Offset=0;let u8ByteLength=strByteOffset-u8ByteOffset;this.u8Buf=new Uint8Array(data,u8ByteOffset,u8ByteLength),this.u8Offset=0;let strBuf=new Uint8Array(data,strByteOffset);this.strBuf=new TextDecoder("utf-8").decode(strBuf),this.strOffset=0}takeU8(){return this.u8Buf[this.u8Offset++]}takeU16(){return this.u16Buf[this.u16Offset++]}takeU32(){return this.u32Buf[this.u32Offset++]}hasMoreU32(){return this.u32Offset<this.u32Buf.length}takeU64(){let low=this.takeU32(),high=this.takeU32();return low+high*4294967296}takeU128(){let low=this.takeU64(),high=this.takeU64();return low+high*18446744073709552000}takeF32(){let intVal=this.takeU32(),intBuf=new Uint32Array(1);return intBuf[0]=intVal,new Float32Array(intBuf.buffer)[0]}takeF64(){let low=this.takeU32(),high=this.takeU32(),intBuf=new Uint32Array(2);return intBuf[0]=low,intBuf[1]=high,new Float64Array(intBuf.buffer)[0]}takeStr(){let len=this.takeU32(),str=this.strBuf.substring(this.strOffset,this.strOffset+len);return this.strOffset+=len,str}takeI8(){let unsigned=this.takeU8();return unsigned>127?unsigned-256:unsigned}takeI16(){let unsigned=this.takeU16();return unsigned>32767?unsigned-65536:unsigned}takeI32(){return this.takeU32()|0}takeI64(){let low=this.takeU32(),signedHigh=this.takeU32()|0;return low+signedHigh*4294967296}takeI128(){let low=this.takeU64(),signedHigh=this.takeU64()|0;return low+signedHigh*18446744073709552000}getRemainingBytes(){return this.u8Buf.subarray(this.u8Offset)}skipBytes(count){this.u8Offset+=count}isEmpty(){return this.u8Offset>=this.u8Buf.length&&this.u16Offset>=this.u16Buf.length&&this.u32Offset>=this.u32Buf.length&&this.strOffset>=this.strBuf.length}}var functionRegistry=null,typeCache=new Map;function getFunctionRegistry(){return functionRegistry}function setFunctionRegistry(registry){functionRegistry=registry}function getTypeCache(){return typeCache}var nativeRefRegistry=new FinalizationRegistry((fnId)=>{let encoder=new DataEncoder;encoder.pushU8(0),encoder.pushU32(DROP_NATIVE_REF_FN_ID),encoder.pushU64(fnId);let response=sync_request_binary("wry://handler",encoder.finalize());handleBinaryResponse(response)});class RustFunction{fnId;paramTypes;returnType;constructor(fnId,paramTypes,returnType){this.fnId=fnId,this.paramTypes=paramTypes,this.returnType=returnType,nativeRefRegistry.register(this,fnId)}call(...args){window.jsHeap.pushBorrowFrame();let encoder=new DataEncoder;encoder.pushU8(0),encoder.pushU32(0),encoder.pushU64(this.fnId);for(let i=0;i<this.paramTypes.length;i++)this.paramTypes[i].encode(encoder,args[i]);let response=sync_request_binary("wry://handler",encoder.finalize()),result=handleBinaryResponse(response);window.jsHeap.popBorrowFrame();let decoded=this.returnType.decode(result);if(result&&!result.isEmpty())throw new Error("Unprocessed data remaining after RustFunction call");return decoded}}class BoolType{encode(encoder,value){encoder.pushU8(value?1:0)}decode(decoder){return decoder.takeU8()!==0}}class HeapRefType{encode(encoder,obj){window.jsHeap.insert(obj)}decode(decoder){let id=decoder.takeU64();return window.jsHeap.get(id)}}class BorrowedRefType{encode(encoder,obj){window.jsHeap.addBorrowedRef(obj)}decode(decoder){let id=decoder.takeU64();return window.jsHeap.get(id)}}class StringType{encode(encoder,value){encoder.pushStr(value)}decode(decoder){return decoder.takeStr()}}class StringEnumType{lookupArray;constructor(lookupArray){this.lookupArray=lookupArray}encode(encoder,value){let index=this.lookupArray.indexOf(value),encoded=index>=0?index:this.lookupArray.length;encoder.pushU32(encoded)}decode(decoder){let index=decoder.takeU32();return this.lookupArray[index]}}class CallbackType{paramTypes;returnType;constructor(paramTypes,returnType){this.paramTypes=paramTypes,this.returnType=returnType}encode(encoder,fnId){encoder.pushU64(fnId)}decode(decoder){let fnId=decoder.takeU64(),f=new RustFunction(fnId,this.paramTypes,this.returnType);return(...args)=>f.call(...args)}}class NullType{encode(encoder,value){}decode(decoder){return null}}class NumericType{size;constructor(size){this.size=size}encode(encoder,value){switch(this.size){case"u8":encoder.pushU8(value);break;case"u16":encoder.pushU16(value);break;case"u32":encoder.pushU32(value);break;case"u64":encoder.pushU64(value);break;case"u128":encoder.pushU128(value);break;case"i8":encoder.pushU8(value&255);break;case"i16":encoder.pushU16(value&65535);break;case"i32":encoder.pushU32(value>>>0);break;case"i64":encoder.pushU64(value);break;case"i128":encoder.pushU128(value);break;case"usize":encoder.pushU64(value);break;case"isize":encoder.pushU64(value);break;case"f32":encoder.pushF32(value);break;case"f64":encoder.pushF64(value);break}}decode(decoder){switch(this.size){case"u8":return decoder.takeU8();case"u16":return decoder.takeU16();case"u32":return decoder.takeU32();case"u64":return decoder.takeU64();case"u128":return decoder.takeU128();case"i8":return decoder.takeI8();case"i16":return decoder.takeI16();case"i32":return decoder.takeI32();case"i64":return decoder.takeI64();case"i128":return decoder.takeI128();case"usize":return decoder.takeU64();case"isize":return decoder.takeI64();case"f32":return decoder.takeF32();case"f64":return decoder.takeF64()}}}class OptionType{wrappedType;constructor(wrappedType){this.wrappedType=wrappedType}encode(encoder,value){if(value===null||value===void 0)encoder.pushU8(0);else encoder.pushU8(1),this.wrappedType.encode(encoder,value)}decode(decoder){if(decoder.takeU8()===0)return null;else return this.wrappedType.decode(decoder)}}class ResultType{okType;errType;constructor(okType,errType){this.okType=okType,this.errType=errType}encode(encoder,value){let result=value;if("ok"in result)encoder.pushU8(1),this.okType.encode(encoder,result.ok);else if("err"in result)encoder.pushU8(0),this.errType.encode(encoder,result.err);else throw new Error("Invalid RustType value: must be Ok or Err")}decode(decoder){if(decoder.takeU8()===1)return{ok:this.okType.decode(decoder)};else return{err:this.errType.decode(decoder)}}}class ArrayType{elementType;constructor(elementType){this.elementType=elementType}encode(encoder,value){encoder.pushU32(value.length);for(let element of value)this.elementType.encode(encoder,element)}decode(decoder){let length=decoder.takeU32(),result=[];for(let i=0;i<length;i++)result.push(this.elementType.decode(decoder));return result}}class U8ClampedType{encode(encoder,value){encoder.pushU32(value.length);for(let i=0;i<value.length;i++)encoder.pushU8(value[i])}decode(decoder){let length=decoder.takeU32(),result=new Uint8ClampedArray(length);for(let i=0;i<length;i++)result[i]=decoder.takeU8();return result}}var u8ClampedTypeInstance=new U8ClampedType,U8Type=new NumericType("u8"),U16Type=new NumericType("u16"),U32Type=new NumericType("u32"),U64Type=new NumericType("u64"),U128Type=new NumericType("u128"),I8Type=new NumericType("i8"),I16Type=new NumericType("i16"),I32Type=new NumericType("i32"),I64Type=new NumericType("i64"),I128Type=new NumericType("i128"),UsizeType=new NumericType("usize"),IsizeType=new NumericType("isize"),F32Type=new NumericType("f32"),F64Type=new NumericType("f64"),strType=new StringType,boolTypeInstance=new BoolType,nullTypeInstance=new NullType,heapRefTypeInstance=new HeapRefType,borrowedRefTypeInstance=new BorrowedRefType,stringTypeInstance=new StringType;function parseTypeDef(bytes,offset){let tag=bytes[offset.value++];switch(tag){case 0:return nullTypeInstance;case 1:return boolTypeInstance;case 2:return U8Type;case 3:return U16Type;case 4:return U32Type;case 5:return U64Type;case 6:return U128Type;case 7:return I8Type;case 8:return I16Type;case 9:return I32Type;case 10:return I64Type;case 11:return I128Type;case 12:return F32Type;case 13:return F64Type;case 14:return UsizeType;case 15:return IsizeType;case 16:return stringTypeInstance;case 17:return heapRefTypeInstance;case 22:return borrowedRefTypeInstance;case 18:{let paramCount=bytes[offset.value++],paramTypes=[];for(let i=0;i<paramCount;i++)paramTypes.push(parseTypeDef(bytes,offset));let returnType=parseTypeDef(bytes,offset);return new CallbackType(paramTypes,returnType)}case 19:{let innerType=parseTypeDef(bytes,offset);return new OptionType(innerType)}case 20:{let okType=parseTypeDef(bytes,offset),errType=parseTypeDef(bytes,offset);return new ResultType(okType,errType)}case 21:{let elementType=parseTypeDef(bytes,offset);return new ArrayType(elementType)}case 23:return u8ClampedTypeInstance;case 24:{let variantCount=bytes[offset.value++],lookupArray=[];for(let i=0;i<variantCount;i++){let len=bytes[offset.value]|bytes[offset.value+1]<<8|bytes[offset.value+2]<<16|bytes[offset.value+3]<<24;offset.value+=4;let strBytes=bytes.subarray(offset.value,offset.value+len);offset.value+=len,lookupArray.push(new TextDecoder().decode(strBytes))}return new StringEnumType(lookupArray)}default:throw new Error(`Unknown TypeTag: ${tag}`)}}var TYPE_CACHED=255,TYPE_FULL=254,DROP_NATIVE_REF_FN_ID=4294967295,CALL_EXPORT_FN_ID=4294967294;function sync_request_binary(endpoint,data){let xhr=new XMLHttpRequest;xhr.open("POST",endpoint,!1),xhr.responseType="arraybuffer";let bytes=new Uint8Array(data),binary="";for(let i=0;i<bytes.length;i++)binary+=String.fromCharCode(bytes[i]);let base64=btoa(binary);if(xhr.setRequestHeader("dioxus-data",base64),xhr.send(),xhr.status===200&&xhr.response)return xhr.response;return null}function evaluate_from_rust_binary(dataBase64){let binary=atob(dataBase64),bytes=new Uint8Array(binary.length);for(let i=0;i<binary.length;i++)bytes[i]=binary.charCodeAt(i);if(handleBinaryResponse(bytes.buffer))throw new Error("Unprocessed data remaining after Evaluate handling")}function parseTypeInfo(decoder){let typeCache2=getTypeCache(),typeMarker=decoder.takeU8();if(typeMarker===TYPE_CACHED){let typeId=decoder.takeU32(),cached=typeCache2.get(typeId);if(!cached)throw new Error(`Unknown cached type ID: ${typeId}`);return cached}else if(typeMarker===TYPE_FULL){let typeId=decoder.takeU32(),paramCount=decoder.takeU8(),typeBytes=decoder.getRemainingBytes(),offset={value:0},paramTypes=[];for(let i=0;i<paramCount;i++)paramTypes.push(parseTypeDef(typeBytes,offset));let returnType=parseTypeDef(typeBytes,offset);decoder.skipBytes(offset.value);let cached={paramTypes,returnType};return typeCache2.set(typeId,cached),cached}else throw new Error(`Unknown type marker: ${typeMarker}`)}function handleBinaryResponse(response){if(!response||response.byteLength===0)return null;let decoder=new DataDecoder(response),msgType=decoder.takeU8();if(msgType===1)return decoder;else if(msgType===0){let encoder=new DataEncoder;encoder.pushU8(1),window.jsHeap.pushBorrowFrame();while(decoder.hasMoreU32()){let fnId=decoder.takeU32(),typeInfo=parseTypeInfo(decoder),jsFunction=getFunctionRegistry()[fnId];if(!jsFunction)throw new Error("Unknown function ID in response: "+fnId);let params=typeInfo.paramTypes.map((paramType)=>paramType.decode(decoder)),result=jsFunction(...params);typeInfo.returnType.encode(encoder,result)}window.jsHeap.popBorrowFrame();let nextResponse=sync_request_binary("wry://handler",encoder.finalize());return handleBinaryResponse(nextResponse)}if(!decoder.isEmpty())throw new Error("Unprocessed data remaining after Evaluate handling");return null}var exportRegistry=new FinalizationRegistry((info)=>{let encoder=new DataEncoder;encoder.pushU8(0),encoder.pushU32(CALL_EXPORT_FN_ID);let dropName=`${info.className}::__drop`;encoder.pushStr(dropName),encoder.pushU32(info.handle);let response=sync_request_binary("wry://handler",encoder.finalize());handleBinaryResponse(response)});function callExport(exportName,...args){window.jsHeap.pushBorrowFrame();let encoder=new DataEncoder;encoder.pushU8(0),encoder.pushU32(CALL_EXPORT_FN_ID),encoder.pushStr(exportName);for(let arg of args)if(typeof arg==="number")encoder.pushU32(arg);else throw new Error(`Unsupported argument type: ${typeof arg}`);let response=sync_request_binary("wry://handler",encoder.finalize()),decoder=handleBinaryResponse(response);if(window.jsHeap.popBorrowFrame(),decoder&&decoder.hasMoreU32())return decoder.takeI32();return}function createWrapper(handle,className){let ClassConstructor=window[className];if(ClassConstructor&&typeof ClassConstructor.__wrap==="function")return ClassConstructor.__wrap(handle);let proxy=new Proxy({__handle:handle,__className:className},{get(target,prop){if(prop==="__handle"||prop==="__className")return target[prop];if(typeof prop==="symbol"||prop==="then"||prop==="toJSON")return;return(...args)=>{let exportName=`${className}::${String(prop)}`;return callExport(exportName,handle,...args)}}});return exportRegistry.register(proxy,{handle,className}),proxy}window.__wryCallExport=callExport;window.__wryExportRegistry=exportRegistry;var rustExports={createWrapper,callExport};window.setFunctionRegistry=setFunctionRegistry;window.evaluate_from_rust_binary=evaluate_from_rust_binary;window.jsHeap=new JSHeap;window.rustExports=rustExports;
