class JSHeap{slots;freeIds;maxId;borrowStackPointer;borrowFrameStack;reservationStack;constructor(){this.slots=[],this.slots[129]=null,this.slots[130]=!0,this.slots[131]=!1,this.slots[128]=void 0,this.freeIds=[],this.maxId=132,this.borrowStackPointer=128,this.borrowFrameStack=[],this.reservationStack=[]}insert(value){const id=this.maxId;return this.maxId++,this.slots[id]=value,id}pushReservationScope(count){const start=this.maxId;this.reservationStack.push({start,count,nextIndex:0}),this.maxId+=count}popReservationScope(){this.reservationStack.pop()}fillNextReserved(value){const scope=this.reservationStack[this.reservationStack.length-1];if(!scope||scope.nextIndex>=scope.count)throw new Error("No reserved slots available");const id=scope.start+scope.nextIndex;scope.nextIndex++,this.slots[id]=value}get(id){return this.slots[id]}remove(id){if(id<132)return this.slots[id];const value=this.slots[id];return delete this.slots[id],this.freeIds.push(id),value}has(id){return this.freeIds.indexOf(id)===-1&&id<this.slots.length}heapObjectsAlive(){return this.slots.length-this.freeIds.length-132}addBorrowedRef(obj){if(this.borrowStackPointer<=1)throw new Error("Borrow stack overflow: too many borrowed references in a single operation");return this.borrowStackPointer--,this.slots[this.borrowStackPointer]=obj,this.borrowStackPointer}pushBorrowFrame(){this.borrowFrameStack.push(this.borrowStackPointer)}popBorrowFrame(){const savedPointer=this.borrowFrameStack.pop();if(savedPointer!==void 0){for(let i=this.borrowStackPointer;i<savedPointer;i++)delete this.slots[i];this.borrowStackPointer=savedPointer}}getBorrowStackPointer(){return this.borrowStackPointer}}class DataEncoder{u8Buf;u16Buf;u32Buf;strBuf;constructor(){this.u8Buf=[],this.u16Buf=[],this.u32Buf=[],this.strBuf=[]}pushU8(value){this.u8Buf.push(value&255)}pushU16(value){this.u16Buf.push(value&65535)}pushU32(value){this.u32Buf.push(value>>>0)}pushU64(value){const low=value>>>0,high=Math.floor(value/4294967296)>>>0;this.pushU32(low),this.pushU32(high)}pushU128(value){const low=value>>>0,high=Math.floor(value/18446744073709550000)>>>0;this.pushU64(low),this.pushU64(high)}pushF32(value){const floatBuf=new Float32Array(1);floatBuf[0]=value;const intBuf=new Uint32Array(floatBuf.buffer);this.pushU32(intBuf[0])}pushF64(value){const floatBuf=new Float64Array(1);floatBuf[0]=value;const intBuf=new Uint32Array(floatBuf.buffer);this.pushU32(intBuf[0]),this.pushU32(intBuf[1])}pushStr(value){const encoded=(new TextEncoder()).encode(value);this.pushU32(encoded.length);for(let i=0;i<encoded.length;i++)this.strBuf.push(encoded[i])}finalize(){const u16Offset=12+this.u32Buf.length*4,u8Offset=u16Offset+this.u16Buf.length*2,strOffset=u8Offset+this.u8Buf.length,totalSize=strOffset+this.strBuf.length,buffer=new ArrayBuffer(totalSize),dataView=new DataView(buffer);dataView.setUint32(0,u16Offset,!0),dataView.setUint32(4,u8Offset,!0),dataView.setUint32(8,strOffset,!0);let offset=12;for(let val of this.u32Buf)dataView.setUint32(offset,val,!0),offset+=4;for(let val of this.u16Buf)dataView.setUint16(offset,val,!0),offset+=2;return new Uint8Array(buffer,u8Offset,this.u8Buf.length).set(this.u8Buf),new Uint8Array(buffer,strOffset,this.strBuf.length).set(this.strBuf),buffer}}class DataDecoder{u8Buf;u8Offset;u16Buf;u16Offset;u32Buf;u32Offset;strBuf;strOffset;constructor(data){const headerView=new DataView(data,0,12),u16ByteOffset=headerView.getUint32(0,!0),u8ByteOffset=headerView.getUint32(4,!0),strByteOffset=headerView.getUint32(8,!0),u32ByteLength=u16ByteOffset-12;this.u32Buf=new Uint32Array(data,12,u32ByteLength/4),this.u32Offset=0;const u16ByteLength=u8ByteOffset-u16ByteOffset;this.u16Buf=new Uint16Array(data,u16ByteOffset,u16ByteLength/2),this.u16Offset=0;const u8ByteLength=strByteOffset-u8ByteOffset;this.u8Buf=new Uint8Array(data,u8ByteOffset,u8ByteLength),this.u8Offset=0;const strBuf=new Uint8Array(data,strByteOffset);this.strBuf=new TextDecoder("utf-8").decode(strBuf),this.strOffset=0}takeU8(){return this.u8Buf[this.u8Offset++]}takeU16(){return this.u16Buf[this.u16Offset++]}takeU32(){return this.u32Buf[this.u32Offset++]}hasMoreU32(){return this.u32Offset<this.u32Buf.length}takeU64(){const low=this.takeU32(),high=this.takeU32();return low+high*4294967296}takeU128(){const low=this.takeU64(),high=this.takeU64();return low+high*18446744073709550000}takeF32(){const intVal=this.takeU32(),intBuf=new Uint32Array(1);return intBuf[0]=intVal,new Float32Array(intBuf.buffer)[0]}takeF64(){const low=this.takeU32(),high=this.takeU32(),intBuf=new Uint32Array(2);return intBuf[0]=low,intBuf[1]=high,new Float64Array(intBuf.buffer)[0]}takeStr(){const len=this.takeU32(),str=this.strBuf.substring(this.strOffset,this.strOffset+len);return this.strOffset+=len,str}takeI8(){const unsigned=this.takeU8();return unsigned>127?unsigned-256:unsigned}takeI16(){const unsigned=this.takeU16();return unsigned>32767?unsigned-65536:unsigned}takeI32(){return this.takeU32()|0}takeI64(){const low=this.takeU32(),signedHigh=this.takeU32()|0;return low+signedHigh*4294967296}takeI128(){const low=this.takeU64(),signedHigh=this.takeU64()|0;return low+signedHigh*18446744073709550000}getRemainingBytes(){return this.u8Buf.subarray(this.u8Offset)}skipBytes(count){this.u8Offset+=count}isEmpty(){return this.u8Offset>=this.u8Buf.length&&this.u16Offset>=this.u16Buf.length&&this.u32Offset>=this.u32Buf.length&&this.strOffset>=this.strBuf.length}}function getFunctionRegistry(){return functionRegistry}function setFunctionRegistry(registry){functionRegistry=registry}function getTypeCache(){return typeCache}var functionRegistry=null,typeCache=new Map;var nativeRefRegistry=new FinalizationRegistry((fnId)=>{const encoder=new DataEncoder;encoder.pushU8(MessageType.Evaluate),encoder.pushU32(DROP_NATIVE_REF_FN_ID),encoder.pushU32(fnId);const response=sync_request_binary("/handler",encoder.finalize());handleBinaryResponse(response)});class RustFunction{fnId;paramTypes;returnType;constructor(fnId,paramTypes,returnType){this.fnId=fnId,this.paramTypes=paramTypes,this.returnType=returnType,nativeRefRegistry.register(this,fnId)}call(...args){window.jsHeap.pushBorrowFrame();const encoder=new DataEncoder;encoder.pushU8(MessageType.Evaluate),encoder.pushU32(0),encoder.pushU32(this.fnId);for(let i=0;i<this.paramTypes.length;i++)this.paramTypes[i].encode(encoder,args[i]);const response=sync_request_binary("/handler",encoder.finalize()),result=handleBinaryResponse(response);window.jsHeap.popBorrowFrame();const decoded=this.returnType.decode(result);if(result&&!result.isEmpty())throw new Error("Unprocessed data remaining after RustFunction call");return decoded}}var parseTypeDef=function(bytes,offset){const tag=bytes[offset.value++];switch(tag){case TypeTag.Null:return nullTypeInstance;case TypeTag.Bool:return boolTypeInstance;case TypeTag.U8:return U8Type;case TypeTag.U16:return U16Type;case TypeTag.U32:return U32Type;case TypeTag.U64:return U64Type;case TypeTag.U128:return U128Type;case TypeTag.I8:return I8Type;case TypeTag.I16:return I16Type;case TypeTag.I32:return I32Type;case TypeTag.I64:return I64Type;case TypeTag.I128:return I128Type;case TypeTag.F32:return F32Type;case TypeTag.F64:return F64Type;case TypeTag.Usize:return UsizeType;case TypeTag.Isize:return IsizeType;case TypeTag.String:return stringTypeInstance;case TypeTag.HeapRef:return heapRefTypeInstance;case TypeTag.BorrowedRef:return borrowedRefTypeInstance;case TypeTag.Callback:{const paramCount=bytes[offset.value++],paramTypes=[];for(let i=0;i<paramCount;i++)paramTypes.push(parseTypeDef(bytes,offset));const returnType=parseTypeDef(bytes,offset);return new CallbackType(paramTypes,returnType)}case TypeTag.Option:{const innerType=parseTypeDef(bytes,offset);return new OptionType(innerType)}case TypeTag.Result:{const okType=parseTypeDef(bytes,offset),errType=parseTypeDef(bytes,offset);return new ResultType(okType,errType)}case TypeTag.Array:{const elementType=parseTypeDef(bytes,offset);return new ArrayType(elementType)}case TypeTag.U8Clamped:return u8ClampedTypeInstance;case TypeTag.StringEnum:{const variantCount=bytes[offset.value++],lookupArray=[];for(let i=0;i<variantCount;i++){const len=bytes[offset.value]|bytes[offset.value+1]<<8|bytes[offset.value+2]<<16|bytes[offset.value+3]<<24;offset.value+=4;const strBytes=bytes.subarray(offset.value,offset.value+len);offset.value+=len,lookupArray.push((new TextDecoder()).decode(strBytes))}return new StringEnumType(lookupArray)}default:throw new Error(`Unknown TypeTag: ${tag}`)}},TypeTag;(function(TypeTag2){TypeTag2[TypeTag2["Null"]=0]="Null";TypeTag2[TypeTag2["Bool"]=1]="Bool";TypeTag2[TypeTag2["U8"]=2]="U8";TypeTag2[TypeTag2["U16"]=3]="U16";TypeTag2[TypeTag2["U32"]=4]="U32";TypeTag2[TypeTag2["U64"]=5]="U64";TypeTag2[TypeTag2["U128"]=6]="U128";TypeTag2[TypeTag2["I8"]=7]="I8";TypeTag2[TypeTag2["I16"]=8]="I16";TypeTag2[TypeTag2["I32"]=9]="I32";TypeTag2[TypeTag2["I64"]=10]="I64";TypeTag2[TypeTag2["I128"]=11]="I128";TypeTag2[TypeTag2["F32"]=12]="F32";TypeTag2[TypeTag2["F64"]=13]="F64";TypeTag2[TypeTag2["Usize"]=14]="Usize";TypeTag2[TypeTag2["Isize"]=15]="Isize";TypeTag2[TypeTag2["String"]=16]="String";TypeTag2[TypeTag2["HeapRef"]=17]="HeapRef";TypeTag2[TypeTag2["Callback"]=18]="Callback";TypeTag2[TypeTag2["Option"]=19]="Option";TypeTag2[TypeTag2["Result"]=20]="Result";TypeTag2[TypeTag2["Array"]=21]="Array";TypeTag2[TypeTag2["BorrowedRef"]=22]="BorrowedRef";TypeTag2[TypeTag2["U8Clamped"]=23]="U8Clamped";TypeTag2[TypeTag2["StringEnum"]=24]="StringEnum"})(TypeTag||(TypeTag={}));class BoolType{encode(encoder,value){encoder.pushU8(value?1:0)}decode(decoder){return decoder.takeU8()!==0}}class HeapRefType{encode(encoder,obj){window.jsHeap.insert(obj)}decode(decoder){const id=decoder.takeU64();return window.jsHeap.get(id)}}class BorrowedRefType{encode(encoder,obj){window.jsHeap.addBorrowedRef(obj)}decode(decoder){const id=decoder.takeU64();return window.jsHeap.get(id)}}class StringType{encode(encoder,value){encoder.pushStr(value)}decode(decoder){return decoder.takeStr()}}class StringEnumType{lookupArray;constructor(lookupArray){this.lookupArray=lookupArray}encode(encoder,value){const index=this.lookupArray.indexOf(value),encoded=index>=0?index:this.lookupArray.length;encoder.pushU32(encoded)}decode(decoder){const index=decoder.takeU32();return this.lookupArray[index]}}class CallbackType{paramTypes;returnType;constructor(paramTypes,returnType){this.paramTypes=paramTypes,this.returnType=returnType}encode(encoder,fnId){encoder.pushU32(fnId)}decode(decoder){const fnId=decoder.takeU32(),f=new RustFunction(fnId,this.paramTypes,this.returnType);return(...args)=>f.call(...args)}}class NullType{encode(encoder,value){}decode(decoder){return null}}class NumericType{size;constructor(size){this.size=size}encode(encoder,value){switch(this.size){case"u8":encoder.pushU8(value);break;case"u16":encoder.pushU16(value);break;case"u32":encoder.pushU32(value);break;case"u64":encoder.pushU64(value);break;case"u128":encoder.pushU128(value);break;case"i8":encoder.pushU8(value&255);break;case"i16":encoder.pushU16(value&65535);break;case"i32":encoder.pushU32(value>>>0);break;case"i64":encoder.pushU64(value);break;case"i128":encoder.pushU128(value);break;case"usize":encoder.pushU64(value);break;case"isize":encoder.pushU64(value);break;case"f32":encoder.pushF32(value);break;case"f64":encoder.pushF64(value);break}}decode(decoder){switch(this.size){case"u8":return decoder.takeU8();case"u16":return decoder.takeU16();case"u32":return decoder.takeU32();case"u64":return decoder.takeU64();case"u128":return decoder.takeU128();case"i8":return decoder.takeI8();case"i16":return decoder.takeI16();case"i32":return decoder.takeI32();case"i64":return decoder.takeI64();case"i128":return decoder.takeI128();case"usize":return decoder.takeU64();case"isize":return decoder.takeI64();case"f32":return decoder.takeF32();case"f64":return decoder.takeF64()}}}class OptionType{wrappedType;constructor(wrappedType){this.wrappedType=wrappedType}encode(encoder,value){if(value===null||value===void 0)encoder.pushU8(0);else encoder.pushU8(1),this.wrappedType.encode(encoder,value)}decode(decoder){if(decoder.takeU8()===0)return null;else return this.wrappedType.decode(decoder)}}class ResultType{okType;errType;constructor(okType,errType){this.okType=okType,this.errType=errType}encode(encoder,value){const result=value;if("ok"in result)encoder.pushU8(1),this.okType.encode(encoder,result.ok);else if("err"in result)encoder.pushU8(0),this.errType.encode(encoder,result.err);else throw new Error("Invalid RustType value: must be Ok or Err")}decode(decoder){if(decoder.takeU8()===1)return{ok:this.okType.decode(decoder)};else return{err:this.errType.decode(decoder)}}}class ArrayType{elementType;constructor(elementType){this.elementType=elementType}encode(encoder,value){encoder.pushU32(value.length);for(let element of value)this.elementType.encode(encoder,element)}decode(decoder){const length=decoder.takeU32(),result=[];for(let i=0;i<length;i++)result.push(this.elementType.decode(decoder));return result}}class U8ClampedType{encode(encoder,value){encoder.pushU32(value.length);for(let i=0;i<value.length;i++)encoder.pushU8(value[i])}decode(decoder){const length=decoder.takeU32(),result=new Uint8ClampedArray(length);for(let i=0;i<length;i++)result[i]=decoder.takeU8();return result}}var u8ClampedTypeInstance=new U8ClampedType,U8Type=new NumericType("u8"),U16Type=new NumericType("u16"),U32Type=new NumericType("u32"),U64Type=new NumericType("u64"),U128Type=new NumericType("u128"),I8Type=new NumericType("i8"),I16Type=new NumericType("i16"),I32Type=new NumericType("i32"),I64Type=new NumericType("i64"),I128Type=new NumericType("i128"),UsizeType=new NumericType("usize"),IsizeType=new NumericType("isize"),F32Type=new NumericType("f32"),F64Type=new NumericType("f64"),strType=new StringType,boolTypeInstance=new BoolType,nullTypeInstance=new NullType,heapRefTypeInstance=new HeapRefType,borrowedRefTypeInstance=new BorrowedRefType,stringTypeInstance=new StringType;var sync_request_binary=function(endpoint,data){const xhr=new XMLHttpRequest;xhr.open("POST",endpoint,!1);const bytes=new Uint8Array(data);let binary="";for(let i=0;i<bytes.length;i++)binary+=String.fromCharCode(bytes[i]);const base64=btoa(binary);if(xhr.setRequestHeader("dioxus-data",base64),xhr.send(),xhr.status===200&&xhr.responseText){const responseBinary=atob(xhr.responseText),responseBytes=new Uint8Array(responseBinary.length);for(let i=0;i<responseBinary.length;i++)responseBytes[i]=responseBinary.charCodeAt(i);return responseBytes.buffer}return null},evaluate_from_rust_binary=function(dataBase64){const binary=atob(dataBase64),bytes=new Uint8Array(binary.length);for(let i=0;i<binary.length;i++)bytes[i]=binary.charCodeAt(i);if(handleBinaryResponse(bytes.buffer))throw new Error("Unprocessed data remaining after Evaluate handling")},parseTypeInfo=function(decoder){const typeCache2=getTypeCache(),typeMarker=decoder.takeU8();if(typeMarker===TYPE_CACHED){const typeId=decoder.takeU32(),cached=typeCache2.get(typeId);if(!cached)throw new Error(`Unknown cached type ID: ${typeId}`);return cached}else if(typeMarker===TYPE_FULL){const typeId=decoder.takeU32(),paramCount=decoder.takeU8(),typeBytes=decoder.getRemainingBytes(),offset={value:0},paramTypes=[];for(let i=0;i<paramCount;i++)paramTypes.push(parseTypeDef(typeBytes,offset));const returnType=parseTypeDef(typeBytes,offset);decoder.skipBytes(offset.value);const cached={paramTypes,returnType};return typeCache2.set(typeId,cached),cached}else throw new Error(`Unknown type marker: ${typeMarker}`)},handleBinaryResponse=function(response){if(!response||response.byteLength===0)return null;const decoder=new DataDecoder(response),msgType=decoder.takeU8();if(msgType===MessageType.Respond)return decoder;else if(msgType===MessageType.Evaluate){const reservedCount=decoder.takeU32();window.jsHeap.pushReservationScope(reservedCount);const encoder=new DataEncoder;encoder.pushU8(MessageType.Respond),window.jsHeap.pushBorrowFrame();while(decoder.hasMoreU32()){const fnId=decoder.takeU32(),typeInfo=parseTypeInfo(decoder),jsFunction=getFunctionRegistry()[fnId];if(!jsFunction)throw new Error("Unknown function ID in response: "+fnId);const params=typeInfo.paramTypes.map((paramType)=>paramType.decode(decoder)),result=jsFunction(...params);if(typeInfo.returnType instanceof HeapRefType&&reservedCount>0)window.jsHeap.fillNextReserved(result);else typeInfo.returnType.encode(encoder,result)}window.jsHeap.popBorrowFrame(),window.jsHeap.popReservationScope();const nextResponse=sync_request_binary("/handler",encoder.finalize());return handleBinaryResponse(nextResponse)}if(!decoder.isEmpty())throw new Error("Unprocessed data remaining after Evaluate handling");return null},MessageType;(function(MessageType2){MessageType2[MessageType2["Evaluate"]=0]="Evaluate";MessageType2[MessageType2["Respond"]=1]="Respond"})(MessageType||(MessageType={}));var TYPE_CACHED=255,TYPE_FULL=254,DROP_NATIVE_REF_FN_ID=4294967295,CALL_EXPORT_FN_ID=4294967294;var callExport=function(exportName,...args){window.jsHeap.pushBorrowFrame();const encoder=new DataEncoder;encoder.pushU8(MessageType.Evaluate),encoder.pushU32(CALL_EXPORT_FN_ID),encoder.pushStr(exportName);for(let arg of args)if(typeof arg==="number")encoder.pushU32(arg);else throw new Error(`Unsupported argument type: ${typeof arg}`);const response=sync_request_binary("/handler",encoder.finalize()),decoder=handleBinaryResponse(response);if(window.jsHeap.popBorrowFrame(),decoder&&decoder.hasMoreU32())return decoder.takeI32();return},createWrapper=function(handle,className){const ClassConstructor=window[className];if(ClassConstructor&&typeof ClassConstructor.__wrap==="function")return ClassConstructor.__wrap(handle);const proxy=new Proxy({__handle:handle,__className:className},{get(target,prop){if(prop==="__handle"||prop==="__className")return target[prop];if(typeof prop==="symbol"||prop==="then"||prop==="toJSON")return;return(...args)=>{const exportName=`${className}::${String(prop)}`;return callExport(exportName,handle,...args)}}});return exportRegistry.register(proxy,{handle,className}),proxy},exportRegistry=new FinalizationRegistry((info)=>{const encoder=new DataEncoder;encoder.pushU8(MessageType.Evaluate),encoder.pushU32(CALL_EXPORT_FN_ID);const dropName=`${info.className}::__drop`;encoder.pushStr(dropName),encoder.pushU32(info.handle);const response=sync_request_binary("/handler",encoder.finalize());handleBinaryResponse(response)});window.__wryCallExport=callExport;window.__wryExportRegistry=exportRegistry;var rustExports={createWrapper,callExport};window.setFunctionRegistry=setFunctionRegistry;window.evaluate_from_rust_binary=evaluate_from_rust_binary;window.jsHeap=new JSHeap;window.rustExports=rustExports;
